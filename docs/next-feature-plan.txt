UPCOMING WORK PLAN
===================

Scope
-----
Plan covers six upcoming capabilities:
1. Course-level learning record toggle defaults.
2. Admin UI controls for the default toggle state.
3. Per-user overrides for course logging preference.
4. Alternate playback mode for audio slideshow lessons.
5. Course list indicator for newly updated lessons.
6. Integrate Dify agent APIs into the app.

Global Assumptions
------------------
- Backend: NestJS + Payload CMS (MongoDB) remain source of truth for courses/lessons.
- Frontend: Expo React Native app syncing learning sessions via AsyncStorage + manual sync API.
- Authentication context and existing course/lesson APIs stay unchanged unless noted.
- We maintain localization (en, zh) for all user-facing text.

Feature Set 1-3: User Preferences & Course Configuration System
---------------------------------------------------------------
Goal: Implement a robust "Configuration Hierarchy" for learning records and sync global user settings (playback speed, etc.) to the server.

Core Concept: Configuration Hierarchy
1. Level 1 (Global/System): App default (Tracking: On).
2. Level 2 (Course Admin): Course default (set by Admin).
3. Level 3 (User Preference): User override (set by User).
Logic: Effective State = User_Override ?? Course_Default ?? True

Backend Tasks (Payload CMS & NestJS)
- Update `courses` Collection:
  * Add `defaultTrackingEnabled` (Boolean, default: true).
  * Expose in API responses.
- Create `user-preferences` Collection (One document per user):
  * Fields:
    - `user`: Relationship to User (unique).
    - `global`: Object storing general settings (e.g., `{ playbackSpeed: number, sessionDuration: number }`).
    - `courseOverrides`: Array of `{ course: Relationship, trackingEnabled: Boolean }`.
  * API: `GET /api/user-preferences/me` (fetch all), `PATCH /api/user-preferences/me` (update global or specific course override).

Frontend Tasks (Expo/React Native)
- State Management:
  * Create `PreferencesContext` to hold global settings and course overrides.
  * On launch/login: Fetch `user-preferences` and cache in AsyncStorage (offline support).
  * Migration: On first run, read legacy local-only settings (playback speed) and sync to server.
- Logic Implementation:
  * Update `session-manager.ts`: Check `User_Override ?? Course_Default` before saving a session.
  * Update Settings Screen: Bind controls (Speed, Duration) to the new synced context.
  * Update Course Detail: Add "Record Learning History" toggle.
- UI/UX:
  * Show "History Paused" indicator on course screens if tracking is disabled.
  * Ensure settings work offline (optimistic updates).

Open Questions
- Conflict resolution: If user changes settings on two devices offline, last write wins?
- Should we migrate existing local settings silently or ask user? (Silent migration preferred).

Feature 4: Audio Slideshow Playback Modes
-----------------------------------------
Goal: Support two playback modes: current autoplay and new "listen & repeat" mode (play clip, pause for imitation or optional speech recognition).

Tasks
- Define module-level mode enum (`auto`, `listenRepeat`). Defaults to current autoplay.
- Backend: allow content editors to set desired mode per audio slideshow module version.
- Frontend player changes:
  * Detect mode and adjust playback behavior.
  * For listen-repeat: insert configurable delays or steps (play clip -> wait N seconds -> continue). Consider per-slide settings vs global default.
  * Provide UI affordances to restart, skip, continue.
  * If speech recognition pursued: scope spike for feasibility (platform APIs, privacy, offline fallback). Otherwise implement timed pause first.
- Update download/cache logic if timing metadata added.
- QA for both modes across locales/devices.

Open Questions
- Are delays fixed, editor-configurable, or user-configurable?
- Speech recognition requirement? If yes, decide library/platform plan.
- Interaction with background audio / system controls.

Feature 5: Course Update Indicator
----------------------------------
Goal: Display a dot or badge on course list items when lessons recently changed until user views updates.

Tasks
- Backend support: track `updatedAt` on lessons (already present). Need course-level aggregate update timestamp.
- Define criteria for "new content" (any lesson updated since user last opened course?).
- Create user-specific state storing last-seen timestamp per course (client + server for multi-device consistency).
- Frontend course list: render badge when `courseUpdatedAt > lastSeenAt`.
- Update course detail screen to mark course as seen when opened (and sync state to server).

Open Questions
- Time window vs last viewed semantics? (e.g., show dot for 7 days vs until user opens course).
- Need push notifications or only in-app indicator?

Feature 6: In-App Dify Agent Integration
----------------------------------------
Goal: Expose Dify-powered agent capabilities within the mobile app for context-aware assistance.

Tasks
- Evaluate Dify API surface: authentication, rate limits, streaming vs batch responses.
- Backend: decide whether requests proxy through our server (for auth/secrets) or go direct from client. Implement proxy endpoint if needed.
- Security: store Dify API credentials securely (server-side env/secret manager). Add request validation, usage limits, and audit logging per user.
- Frontend: design agent entry point (e.g., chat panel, contextual assistant in lessons). Implement UI to send prompts, render responses (streaming if available), and handle errors/retries.
- Context injection: determine what course/lesson/session metadata should be passed to the agent (respect privacy and consent). Implement payload shaping.
- Offline handling + fallback messaging when service unavailable.
- Analytics/telemetry: track usage volumes, user satisfaction prompts.

Open Questions
- Primary use cases (general Q&A, lesson help, translation?). Need to define to scope UI and context payloads.
- Should assistant be global or course-specific? Multi-language response requirements?
- Rate limiting per user/session to control costs.
- Do we need moderation filters before showing responses?

Cross-Cutting Considerations
-----------------------------
- Authorization: ensure new endpoints respect user roles (admins vs standard users).
- Migration strategy: data backfill for existing records when deploying.
- Telemetry/analytics: decide if toggles or mode changes require tracking.
- Testing: plan unit/integration/e2e coverage for backend and frontend changes. Update manual QA checklist.
- Documentation: update admin guides, user help copy, and release notes.

Next Steps
----------
1. Review open questions with stakeholders to finalize UX/behavior decisions.
2. Break plan into tickets grouped by feature (backend + frontend tasks paired).
3. Sequence work: start with backend schema + API for course logging defaults (Feature 1), then admin UI (Feature 2), followed by user overrides (Feature 3). Parallel spike for Feature 4 requirements, then implement once logging features stabilize. Feature 5 depends on decision about user last-seen tracking.
4. Schedule design review for UI touchpoints (course screen toggle, audio player mode selector, course list badges).
